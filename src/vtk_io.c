#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "headers/vtk_io.h"

// VTK encodes binary image data as big-endian, so a conversion
// may be needed according to the architecture.

#define IS_BIG_ENDIAN (*(uint16_t*) "\0\xff" < 0x100)

static inline FLOATING _swap_float_32(const FLOATING value) {
    FLOATING result;
    char *result_ptr = (char*) &result;
    char *input_ptr = (char*) &value;

    result_ptr[0] = input_ptr[3];
    result_ptr[1] = input_ptr[2];
    result_ptr[2] = input_ptr[1];
    result_ptr[3] = input_ptr[0];

    return result;
}

static inline FLOATING _swap_float_64(const FLOATING value) {
    FLOATING result;
    char *result_ptr = (char*) &result;
    char *input_ptr = (char*) &value;

    result_ptr[0] = input_ptr[7];
    result_ptr[1] = input_ptr[6];
    result_ptr[2] = input_ptr[5];
    result_ptr[3] = input_ptr[4];
    result_ptr[4] = input_ptr[3];
    result_ptr[5] = input_ptr[2];
    result_ptr[6] = input_ptr[1];
    result_ptr[7] = input_ptr[0];

    return result;
}

// Slower but size-agnostic fallback
static inline FLOATING _swap_float_any(const FLOATING value) {
    FLOATING result;
    char *p = (char*) &value;
    char *q = (char*) &result;
    unsigned i;
    for (i = 0; i < sizeof (FLOATING); ++i) {
        q[i] = p[sizeof (FLOATING) - i - 1];
    }
    return result;
}

// Dummy for big-endian, will be erased by the compiler
// if optimisation is enabled
static inline FLOATING _swap_nothing(const FLOATING value) {
    return value;
}

// Choose the right function according to the size of the type
#define swapping_function \
    ((IS_BIG_ENDIAN) ? _swap_nothing : \
     (sizeof (FLOATING) == 4) ? _swap_float_32 : \
     (sizeof (FLOATING) == 8) ? _swap_float_64 : \
     _swap_float_any)

/*!
 * \brief Write to file a vector field in VTK (STRUCTURED_POINTS) format.
 */
void write_vtk(
        const char *filename,                /*!< Filename */
        const Image f
        )
{
    size_t i = 0ul;

    // Allocate a buffer and copy the image data in it
    double *buffer = (double*) malloc(f.nd * f.nx * f.ny * f.nz * sizeof (double));
    FLOATING (* const swap_bytes)(FLOATING) = swapping_function;

    for (size_t z = 0; z < f.nz; ++z) {
        for (size_t y = 0; y < f.ny; ++y) {
            for (size_t x = 0; x < f.nx; ++x) {
                for (size_t d = 0; d < f.nd; ++d) {
                    buffer[i++] = swap_bytes(_(f, x, y, z, d));
                }
            }
        }
    }

    FILE *fp = fopen(filename, "wb");
    GENERIC_ERROR_HANDLER(!fp);

    fprintf(fp,
            "# vtk DataFile Version 3.0\n"
            "Generated by %s defined in %s\n"
            "BINARY\n"
            "DATASET STRUCTURED_POINTS\n"
            "DIMENSIONS %lu %lu %lu\n"
            "ORIGIN 0 0 0\n"
            "SPACING %f %f %f\n"
            "POINT_DATA %lu\n"
            "SCALARS image_data double %lu\n"
            "LOOKUP_TABLE default\n",
            __func__,
            __FILE__,
            f.nx, f.ny, f.nz,
            f.dx, f.dy, f.dz,
            f.nx * f.ny * f.nz,
            f.nd
            );
    fwrite(buffer, sizeof (double), f.nd * f.nx * f.ny * f.nz, fp);

    fclose(fp);
    free(buffer);
}

/*!
 * \brief Read from file a vector field in VTK (STRUCTURED_POINTS) format.
 */
Image read_vtk(
        const char *filename /*!< Filename */
        )
{
    size_t nx = 0, ny = 0, nz = 0, nd = 0;
    float fdx, fdy, fdz;
    FLOATING dx, dy, dz;
    size_t i = 0ul;

    FLOATING (* const swap_bytes)(FLOATING) = swapping_function;

    const unsigned buf_len = 255u;
    char line_buffer[buf_len];

    FILE *fp = fopen(filename, "rb");
    GENERIC_ERROR_HANDLER(!fp);

    int flt = 0;
    int dbl = 0;

    // This is a simple but ugly solution to parse the header
    while (fgets(line_buffer, buf_len, fp) && line_buffer[0] != 'L') {
        sscanf(line_buffer, "DIMENSIONS %lu %lu %lu", &nx, &ny, &nz);
        sscanf(line_buffer, "SPACING %f %f %f", &fdx, &fdy, &fdz);
        dbl = sscanf(line_buffer, "SCALARS %*s double %lu", &nd);
        flt = sscanf(line_buffer, "SCALARS %*s float %lu", &nd);
    }
    dx = (FLOATING) fdx;
    dy = (FLOATING) fdy;
    dz = (FLOATING) fdz;

    // TODO add float support
    if (flt) {
        (void) dbl;
        printf("%s:%d, function %s: float type not supported\n", __FILE__, __LINE__, __func__);
        exit(EXIT_FAILURE);
    }

    verbose_printf(DISPTOOLS_DEBUG, "%lu %lu %lu %lu %f %f %f\n", nd, nx, ny, nz, dx, dy, dz);

    // Allocate memory for a buffer and read image data

    const size_t element_count = nd * nx * ny * nz;

    double *buffer = (double*) malloc(element_count * sizeof (double));
    GENERIC_ERROR_HANDLER(!buffer);

    fread(buffer, sizeof (double), element_count, fp);

    fclose(fp);

    // Allocate memory for the data structure
    Image f = new_image(nd, nx, ny, nz, dx, dy, dz);

    // Copy data from the buffer to the data structure
    for (size_t z = 0; z < f.nz; ++z) {
        for (size_t y = 0; y < f.ny; ++y) {
            for (size_t x = 0; x < f.nx; ++x) {
                for (size_t d = 0; d < f.nd; ++d) {
                    _(f, x, y, z, d) = swap_bytes(buffer[i++]);
                }
            }
        }
    }

    free(buffer);

    return f;
}
